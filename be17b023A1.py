# -*- coding: utf-8 -*-
"""Computational Neuroscience.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ygN8KezzDcEBU5h1tm5djzd6gqdhmwsv
"""

# BT6270 Assignment 1
# NIVETHITHAN M BE17B023
# DATED: 7/10/2020

import matplotlib.pyplot as plt
import numpy as np
import math as math

#THIS PROGRAM DEMONSTRATES THE VARIATION OF DOMINANT ACTION POTENTIAL FRQUENCY WRT INPUT CURRENT PROVIDED

#Time is in secs, voltage in mvs, conductances in m mho/mm^2, capacitance in uF/mm^2

#threshold value of current is 0.0223

#ImpCur=input('enter the value of the impulse current in microamperes: ');
#TimeTot=input('enter the time for which stimulus is applied in milliseconds');

# FUNCTION TO GET THE VOLTAGES UNTIL TIME 10s WHEN AN ImpCur IS PROVIDED
def getVdata(ImpCur):  
  gkmax=.36
  vk=-77 
  gnamax=1.20
  vna=50;
  gl=0.003
  vl=-54.387
  cm=.01
  v=-64.9964;
  m=0.0530;
  h=0.5960;
  n=0.3177;
  dt=0.01
  niter=10000;
  iapp=ImpCur*np.ones(niter)
  vhist=np.zeros(niter);
  mhist=np.zeros(niter);
  hhist=np.zeros(niter);
  nhist=np.zeros(niter);
  
  for iter in range(1,niter):   
    gna=gnamax*pow(m,3)*h; 
    gk=gkmax*pow(n,4); 
    gtot=gna+gk+gl;
    vinf = ((gna*vna+gk*vk+gl*vl)+ iapp[iter])/gtot;
    tauv = cm/gtot;
    v=vinf+(v-vinf)*math.exp(-dt/tauv);
    alpham = 0.1*(v+40)/(1-math.exp(-(v+40)/10));
    betam = 4*math.exp(-0.0556*(v+65));
    alphan = 0.01*(v+55)/(1-math.exp(-(v+55)/10));
    betan = 0.125*math.exp(-(v+65)/80);
    alphah = 0.07*math.exp(-0.05*(v+65));
    betah = 1/(1+math.exp(-0.1*(v+35)));
    taum = 1/(alpham+betam);
    tauh = 1/(alphah+betah);
    taun = 1/(alphan+betan);
    minf = alpham*taum;
    hinf = alphah*tauh;
    ninf = alphan*taun;
    m=minf+(m-minf)*math.exp(-dt/taum);
    h=hinf+(h-hinf)*math.exp(-dt/tauh);
    n=ninf+(n-ninf)*math.exp(-dt/taun);
    vhist[iter]=v; 
    mhist[iter]=m; 
    hhist[iter]=h; 
    nhist[iter]=n; 
  return vhist

# FUNCTION TO TRANSFORM A GIVEN (ALMOST UNIFORM) SIGNAL TO A FREQUENCY AND RETURN THE DOMINANT ONE
def transform(vhist):
  n = len(vhist)
  currPeak = np.zeros((n,), dtype=int)  # currPeak stores the position of peaks
  k = 0
  time_interval = 0 # time_interval stores the time window of all the spikes
  time_interval_initial = 0 # time_interval_initial stores the position of the first peak
  time_interval_final = 0 # time_interval_initial stores the position of the last peak
  number_of_peaks = 0 # total no of peaks in the given signal
  num = currPeak[k] # updates the new peak's search start point
  for i in range(num,n-1):
    if(vhist[i] > vhist[i-1] and vhist[i] > vhist[i+1] and vhist[i] > 10):      
      currPeak[k] = i
      time_interval_final = i
      # update time_interval_initial only for the first peak
      if(k == 0):
        time_interval_initial = i
      k += 1
      number_of_peaks += 1
    num = currPeak[k]
  time_interval  = time_interval_final - time_interval_initial
  # Take time_interval to be valid only if it has considerable window say > 7000 points
  # constants are multiplied to get the result in terms of frequencies
  if(time_interval >= 7000):
    value = (number_of_peaks/time_interval)*n*10
  else:
    value = number_of_peaks*10
  return value

# <------ ACTUAL CODE FROM HERE ----->
nciter = 700 # Takes the window of 700 datapoints. Here 0 to 0.7 mAmp
transformed = np.zeros(nciter); 

# Compute the No of spikes per second for the range of Input current
for citer in range(1,nciter):
  val = getVdata(citer*0.001);
  freqs = transform(val);
  transformed[citer] = freqs;

arr = list(0.001*i for i in range(0,nciter)) # Array containing the point labels

# Plot!!!
plt.plot(arr,transformed)
plt.xlabel('Input Current') 
plt.ylabel('No of Spikes per second') 
plt.title('Input Current vs No of Spikes per second')   
plt.show() 

# PRINT I1, I2 and I3
I1 = 0
for i in range (1,nciter):
  if(I1 == 0):
    if(transformed[i] - transformed[i-1] > 0): # No Action potential threshold current
      I1 = (i)*0.001
  if(transformed[i] - transformed[i-10] > 40): # Finite Action potential threshold current
    I2 = (i-10)*0.001
  if( transformed[i-10] - transformed[i] > 80): # Continuous firing and distorted Action potentials
    I3 = (i-10)*0.001 

print('I1: '+ str(I1))
print('\nI2: '+ str(I2))
print('\nI3: '+ str(I3))